---
title: "Die ersten Wochen: PhD"
date: 29-01-2020
author: Justus Adam
published: true
---


Der PhD (steht f√ºr Doctor of Philosophy) kommt sehr gut voran. Ich denke f√ºr die
wenige Zeit, die ich bis jetzt hatte um daran zu arbeiten bin ich schon weit
voran gekommen. Aber um das ganze mal etwas in den Zusammenhang zu setzen sollte
ich vielleicht kurz erkl√§ren worum es eigentlich geht. Das hat zumindest Robert
vorgeschlagen.

## Worum es eigentlich geht

Mein PhD besch√§ftigt sich mit Type Checking. Genauer gesagt versuche ich
die Untersuchungen von Datentypen, wie es sie in fortschrittlicheren, st√§rkeren
Typsystemen schon gibt, auf √§ltere und schw√§chere Typsysteme zu adaptieren.

Das hat jetzt sicher kaum einer verstanden, daher beschreibe ich das noch mal ein
wenig anwendungsbezogener. Ein Computerprogramm besteht essentiell aus 2 Dingen.
Einerseits Daten, zum Beispiel Zahlen, Text oder Listen davon. Und andererseits
Operationen auf diesen Daten, zum Beispiel Addition oder Formen der Inspektion
wie beispielsweise das Z√§hlen von Buchstaben.

### Grundlagen der Typtheorie

In einem **Typsystem** wird jedem Datenitem ein Typ, d.h. eine Bezeichnung
zugewiesen, entweder durch den Programmierer oder automatisch durch das System.
In der Regel ist der Typ f√ºr eine ganze Zahl `Integer`, f√ºr Text `String` und
eine Liste davon w√§re entsprechend `List<Integer>` oder `List<String>`.

Dazu werden jeder Operation die Typen f√ºr die Argumente zugewiesen, sowie die
der Typ von Daten, den die Operation zur√ºck gibt. Also Addition zum Beispiel
h√§tte die Argumenttypen `(Integer, Integer)` und den R√ºckgabetyp `Integer`.
Sie addiert zwei ganze Zahlen und gibt eine als Ergebnis zur√ºck. Die
Operation, welche Buchstaben in einem Text z√§hlt hat die Argumenttypen
`(String)` und den R√ºckgabetyp `Integer`.

Ein **Typchecker** untersucht dann das Programm und stellt sicher, dass
die Typen der Argumente einer Operationen immer zu den deklarierten
Argumenttypen passen. Zum Beispiel `1 + 1` ist legal, da `1` ein `Integer` ist
und es somit mit den Argumenttypen f√ºr Addition √ºbereinstimmt. In selber Weise ist
`Z√§hleBuchstaben("Ein St√ºck Text")`[^1] legal.

[^1]: In den meisten Programmiersprachen wird Text mit doppelten
    Anf√ºhrungszeichen dargestellt.

### Casts

Das sind jetzt sehr einfache Beispiele. Wenn Programme gr√∂√üer werden braucht man
bisweilen wesentlich kompliziertere Interaktionen zwischen den Typen. Besonders
h√§ufig muss man Daten, die zwar strukturell unterschiedlich sind, aber eine
Gemeinsamkeit ausweisen, generalisieren und diese Gemeinsamkeit als Datentyp f√ºr
jene Daten verwenden.

Als Beispiel aus der realen Welt nehmen wir ein gelochtes Blatt Papier
(`Papier`) und eine Klarsichtfolie (`Folie`). Beide sind offensichtlich sehr
unterschiedlich in ihrer Struktur. Allerdings sind beide gelocht und k√∂nnen
daher eingeheftet werden. In einem Programm w√ºrde man daf√ºr einen neuen Typ
einf√ºhren, nennen wir ihn mal `Heftbar`. Sagen wir mal ich w√∂llte diese jetzt
einheften, dann w√§re eine m√∂gliche Operation vielleicht `einheften(Hefter,
Heftbar) -> Hefter`. Diese Operation nimmt also einen `Hefter` und gibt den
`Hefter` wieder zur√ºck, mit dem neuen `Heftbar` eingeheftet. Da sowohl `Papier`
als auch `Folie` `Heftbar` sind kann ich also beide in den gleichen `Hefter`
einheften. Ich denke es ist jedem klar, dass das praktisch ist.

Das eigentliche Problem tritt jetzt auf wenn ich wieder aushefte. Eine
Operation, die das tun k√∂nnte w√§re `ausheften(Hefter) -> (Hefter, Heftbar)`. Wie
ihr seht ist die Signatur dieser Operation genau umgekehrt zu `einheften`. Das
ist problematisch, da ich jetzt also ein `Heftbar` erhalte und kein `Papier`
oder eine `Folie`. Warum? Weil der `Hefter` nicht wei√ü ob es eine `Folie` oder
ein `Papier` ist. Darum k√ºmmert sich der `Hefter` nicht. Ihn interessiert nur,
dass alles `Heftbar` ist. Wenn ich das soeben Ausgeheftete aber zum Beispiel
beschreiben m√∂chte muss ich aber wissen, ob es sich um ein `Papier` oder eine
`Folie` handelt. Denn auf das `Papier` k√∂nnte ich schreiben, auf die `Folie`
nicht.

Manchmal tritt nun die Situation auf, dass ein Programmierer ganz sicher wei√ü
(oder zu wissen glaubt), dass in *diesem* `Hefter` *ausschlie√ülich* `Papier`
eingeheftet wurde . Dann kann er das Ausgeheftete einfach als `Papier`
behandeln und drauf los schreiben. In der Programmierung nennen wir das einen
**cast**. Das s√§he dann ungef√§hr so aus: `beschreibe((Papier)
ausgeheftetesBlatt, "Text zum draufschreiben")`. Der cast ist `(Papier)
ausgeheftetesBlatt` womit man dem Typchecker sagt "benutze
`ausgeheftetesBlatt` als `Papier`!".

Mit dieser Operation umgeht man die Sicherheiten des Typsystems. Dieses kann nun
nicht mehr garantieren, das wir die Daten in unserem Programm korrekt verwenden.
Wenn so ein cast falsch angewendet wird, also zum Beispiel *doch* eine `Folie`
in dem Hefter war dann k√∂nnen, je nach Programmiersprache schlimme Dinge
geschehen.

In Java beispielsweise wird eine `Exception` geworfen. Das bedeutet, das
Programm ist im Ausnahmezustand und wird beginnen die Ausf√ºhrung zu beenden bis
ein anderer Programmteil die Situation untersucht und verarbeitet oder, wenn das
nicht passiert, terminiert das Programm. Das ist eine unangenehme √úberraschung
f√ºr einen Benutzer, wenn pl√∂tzlich, ohne Vorwarnung, das Programm abst√ºrzt.

Allerdings sind die Java Fehler noch harmlos. In C beispielsweise wird das
Programm gar nicht *merken*, dass es einen falschen Cast gemacht hat. Es wird
sehr wahrscheinlich die Daten korrumpieren[^k] und andere Programmteile werden
sie nicht mehr korrekt verwenden k√∂nnen. Das ist im Prinzip passiert genau das
was man erwarten w√ºrde. Die `beschreibe` Operation tut einfach so, als h√§tte sie
ein `Papier` vor sich und f√§ngt an auf der Folie herum zu kritzeln. Die Folie
ist danach nat√ºrlich nicht mehr zu gebrauchen, was das Programm aber ebenfalls
nicht merkt, sondern es wir einfach nicht mehr lesen k√∂nnen was in der Folie
ist, weil die Kritzeleien das Darunterliegende zu unleserlich machen.

[^k]: Ich habe keine bessere √úbersetzung daf√ºr gefunden. Es hei√üt im prinzip nur
    so viel, dass die Daten in einen Zustand gebracht werden, in dem sie nicht
    sein sollten oder nicht sein d√ºrfen.

### üéì Inhalt des PhD

Meine Arbeit besch√§ftigt sich nun damit sicher zu stellen, dass das auch funktioniert.
Ich werde ein Werkzeug entwerfen und bauen[^w], das in solchen F√§llen das Programm analysiert
und pr√ºft, dass in diesem `Hefter` wirklich nur `Papier` ist, da der
normale Typchecker das nicht kann. Besonders vorteilhaft hier ist, dass die
Analyse schon l√§uft w√§hrend das Programm geschrieben wird und man dem Programmierer
solche Fehler direkt melden kann, anstatt erst sp√§ter wenn das Programm schon
l√§uft.

[^w]: Mit Werkzeug ist hier nat√ºrlich auch ein Programm gemein. Programme, die
    Programme analysieren, ja, soetwas gibt es in meiner Informatik-Unterkategorie
    dauernd :D

Ich sollte vielleicht dazu sagen, dass solche *casts* vor allem bei √§lteren
Typsystemen notwendig sind. Mittlerweile gibt es viele neuere Typsysteme, die
*diese* Arten von Fehlern nicht mehr haben. In der Regel spricht man dann von
einem *st√§rkeren* Typsystem. St√§rke wird hier im Sinne von "K√∂nnen" verwendet,
solche Typsysteme *k√∂nnen* diese komplizierteren Zusammenh√§nge abbilden und
verstehen.

Leider ist es aber so, dass Typsysteme in der regel sehr stark mit ihrer
jeweiligen Programmiersprache verbunden sind. Man kann nicht so einfach einer
alten Programmiersprache ein neues Typsystem verpassen. Das f√ºhrt mindestens
dazu, dass einige Programme, die in dieser Sprache geschrieben sind, dann mit
der neueren Version nicht mehr funktionieren. Und bisweilen ist es tats√§chlich
*beweisbar*, dass man es nicht tun kann ohne den fundamentalen Charakter der
Sprache zu ver√§ndern. Man m√ºsste also, um ein st√§rkeres Typsystem verwenden zu
k√∂nnen, sein Programm in einer neuen Sprache neu schreiben, und das ist je nach
Gr√∂√üe des Programms schwierig bis effektiv unm√∂glich.

### üîß Wie arbeitet mein Werkzeug?

Die Art und Weise, auf die mein Werkzeug diese Typen checken soll, ist, indem es
zun√§chst die Teile des Programms, die einen Einfluss darauf haben was in dem
`Hefter` landet, extrahiert. Diese Technik nennt man "Program Slicing", also
"Programm Zerschneidung" oder "Zerteilung". Ein "slice" ist im wahrsten Sinne
des Wortes eine Scheibe. Mein Werkzeug schaut sich also an wo die Dinge
herkommen, die im `Hefter` sind.

Das kann man sich so vorstellen als w√ºrde man die Frage stellen "Was wei√ü Justus
Adam √ºber Computer" aber man d√ºrfte mich nicht direkt fragen. Man k√∂nnte es
berechnen, wenn man w√ºsste, was ich √ºber Computer alles gelernt habe. Dazu w√ºrde
man die Chronologie meines Lebens nehmen und alle die Momente heraussuchen, in
denen ich etwas gelernt habe, **und dann**, f√ºr jeden der Menschen, die mir
etwas beigebracht haben heraussuchen wann **sie** etwas gelernt haben und so
weiter, bis alle Urspr√ºnge meines Wissens gefunden worden w√§ren.[^5]

[^5]: Das Beispiel ist nicht ganz richtig, da es keinen gut definierten Ursprung
    f√ºr Wissen gibt, w√§hrend ein Programm definitiv einen wohl definierten
    Beginn hat (n√§mlich wenn man es startet). Die suche nach dem Wissen w√ºrde
    also nie enden, w√§hrend die Suche im Programm sp√§testens dann endet, wenn
    wir am Start ankommen.

In diesem Beispiel ist mein Computerwissen die m√∂glichen Typen von Daten, die im
`Hefter` gelandet sein k√∂nnten und die Chronologie ist das ganze Programm. Mit
der Suche von gerade eben haben wir einen *slice* der Geschichte erstellt, was nur
darauf ausgelegt ist, mein Computerwissen zu erzeugen. Wenn wir also wissen
wollen, was dieses Wissen ist, k√∂nnen wir einfach den Ablauf dieser
Lernereignisse simulieren und so das Wissen berechnen.

In der echten Welt ist das schwierig, aber in einem Programm steht ja ganz genau
drin, was passiert. Und genau das tut mein Werkzeug. Es nimmt sich den *slice*
und simuliert die Ausf√ºhrung, um (ich wechsle hier wieder die Analogien)
feststellen zu k√∂nnen, welche (Arten von) Typen *effektiv* in dem `Hefter`
landen k√∂nnten.

Diese Technik nennt sich "Symbolic Execution", also symbolische Ausf√ºhrung. Sie
ist sehr rechenintensiv, weshalb wir vorher das *slicing* anwenden, um das
Programm auf die Berechnung einiger interssanter Werte zu reduzieren.

## üìÖ Das erste Jahr


Mittlerweile habe ich mit meinem Dokotorvater einen Plan aufgestellt, was im
ersten Jahr so passieren wird.

√úblicherweise ist der Gro√üteil des ersten Jahres gef√ºllt mit Literaturrecherche.
Ganz getreu dieser Tradition werde auch ich jetzt erst mal vor allem Paper
lesen. Es vor allem wichtig herauszufinden was f√ºr Werkzeuge bereits existieren
die √§hnliche Hilfen bieten. Dabei gilt es folgendes herauszufinden:

1. Welche Arten von (Programmier-)Fehlern treten wie oft auf.
2. Welche existierenden Werkzeuge k√∂nnen welche dieser Fehler finden.
3. Wie viel zus√§tzliche Informationen brauchen diese Werkzeuge von Programmierer.
3. Wie lange brauche diese Werkzeuge um Antworten zu liefern.

Ein Werkzeug, was nur wenige Sekunden braucht eignet sich besonders w√§hrend der
Entwicklungsphase kontinuierlich zu laufen, w√§hrend eines, was mehrere Stunden
ben√∂tigt, viel seltener verwendet werden wird. (man l√§sst es dann zB. √ºber Nacht laufen)

Das ist deswegen interessant, weil mein Projekt zum Ziel hat einen bestimmten
*Teil* der m√∂glichen Fehler in kurzer Zeit zu finden, und das ohne zus√§tzliche
Informationen durch den Programmierer. Nun gilt es jetzt zu kl√§ren, ob eben genau
diese Nische schon abgedeckt wurde. Ich habe f√ºr meine Kategorisierung der Fehler
auch schon eine sehr gute erste Studie gefunden!

Gleichzeitig zur dieser Recherche werde ich auch noch verschiedenste Sachen √ºber
die Technologien lesen, die wir f√ºr das Werkzeug verwenden wollen. Daraus werde
ich mir dann im Laufe der Zeit einen Prototypen des Systems bauen.

Zum Ende des Jahres hin werde ich dann aufschreiben, was bei diesen Recherchen,
sowie weiter eigener Tests und Nachforschungen herausgekommen ist. Daraus
zaubern wir dann ein Paper, was wir bei einem Workshop einreichen werden. Je
nach dem wie umfangreich alles war wird es entweder ein Paper oder zwei, eins
f√ºr die Experimente/Forschung mit dem Prototypen, und eins f√ºr die Analyse der
Fehler und die bestehenden Werkzeuge.

Und so sieht die Zeittabelle aus, die ich daf√ºr entworfen habe:

| Months              | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|---------------------|---|---|---|---|---|---|---|---|---|----|----|----|
| Literature Review   | x | x | x | x | x | x | x |   |   |    |    |    |
| Prototype           |   | x | x | x | x | x | x | x | x |    |    |    |
| Audience Evaluation |   |   |   |   |   | x | x | x | x | x  | x  |    |
| Paper               |   |   |   |   |   |   |   |   |   | x  | x  | x  |
| Networking          |   |   |   |   |   |   | x |   |   |    |    | x  |
|---------------------|---|---|---|---|---|---|---|---|---|----|----|----|

Wie ihr seht steht da auch *Networking* drin, damit ist gemein zu Konferenzen zu
fahren. Mindestens einmal f√ºr das/die Paper und vielleicht noch ein zweites Mal,
etwas fr√ºher, einfach nur so.

## Neuigkeiten

Auf die Idee bin ich bei der "Kickstart your PhD" Veranstaltung gekommen. Die
war zwar jetzt nicht so super interessant und hilfreich, hat aber Denkanst√∂√üe
bewirkt. Kurz darauf hatte ich mein 2. Treffen mit Stephen, meinem Doktorvater,
und im Gespr√§ch hat sich dann dieser Plan ganz nat√ºrlich ergeben.

Diese Woche gab es auch noch mal eine Einf√ºhrung f√ºr PhD Studenten in der School
of Computing im speziellen. Das war ganz interessant, weil da vor allem die
Pr√ºfungsmodalit√§ten erkl√§rt wurden, also was f√ºr Hardware f√ºr Experimente etc.
zur Verf√ºgung seht.

Hier in England ist die Verteidigung n√§mlich anders. Das ist kein √∂ffentlicher
Vortrag, sondern ganz privat, nur mit den 2 Pr√ºfern. Es gibt auch keine Noten
("Suma cum laude" und so) daf√ºr aber "corrections". Das bedeutet, dass man (in
der Regel) nach der Verteidigung eine Liste mit Verbesserungen bekommt, die man
noch in die Arbeit einpflegen muss, bevor die Endg√ºltige Version abgenickt wird.
Das k√∂nnen kleinere √Ñnderungen sein ("minor corrections") oder gr√∂√üere
("revision") oder man muss die Arbeit ein Jahr sp√§ter noch mal abgeben
("resubmission").

Apropos Noten, ich hab mittlerweile auch die Endnote f√ºr meinen Master noch
erfahren. Nicht das es irgendjemanden interessiert, da ich ja eh schon hier
genommen wurde, aber am Ende ist es eine 1.4 f√ºr den gesamten Master geworden.
Das ist schon ganz nett. Ich bin Justus und ich bin ein alter Streber und Angeber![^3]

[^3]: Kommentar des Lektors

Und jetzt hab ich noch ein paar ganz spannende Neuigkeiten. Es steht zwar noch
nicht 100% fest, aber es sieht wohl ganz so aus als w√ºrde ich √ºber den Sommer
nicht nur f√ºr meine geplanten 2 Wochen Konferenzen in den Staaten sein, sondern
ganze 3 Monate. Ich wurde n√§mlich von Microsoft Research gefragt, ob ich Lust
h√§tte ein Forschungspraktikum zu machen. Gestern Abend habe ich mit zwei von
deren Forschern gesprochen und ich denke ich hab dabei einen ganz guten Eindruck
hinterlassen. Wir wollen uns in 2 Wochen noch einmal unterhalten und bis dahin soll
ich mir mal die Projekte ihrer Gruppe anschauen und sagen ob mich irgendwas
davon interessieren w√ºrde. Das klingt schon mal ganz nice, zumal ich geh√∂rt
habe, dass solche Praktika in der Regel ganz gut bezahlt werden.

Ach ja und als letztes wollte ich noch erw√§hnen, dass es hier (fast) jeden
Dienstag um halb vier Kuchen gibt. üç∞üíü

Leider hab ich davon kein Foto gemacht ...

Und damit bin ich am Ende. Heute war ein bisschen starker Tobak, aber ich hoffe
das hilft euch ein bisschen besser zu verstehen, was ich in n√§chster Zeit so
versuchen werde zu tun.

üá™üá∫üá¨üáß Heute ist Brexit Tag, oder wie es in der Kaffeek√ºche schon sarkastisch genannt
wurde "Independence Day". Ich gr√º√üe euch also alle jetzt offiziell von au√üerhalb
der EU. üò¢ üëã üá¨üáßüá™üá∫
